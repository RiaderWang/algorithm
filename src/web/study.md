重点章节：4,11,12

2021-02-03
    cap1：
        1：v8的两个主要组成部分：内存堆（数据存储的地方） 调用栈（代码执行的地方）。
        2：有一些浏览器的api不是由js引擎提供的，如dom,定时器（setTimeout），ajax等，我们称之为web api。
        3：js是一种单线程编程语言，只有一个调用堆栈。调用栈是一种数据结构，记录了我们在程序中的位置。运行一个函数时，它会将其放到栈顶，当从这个函数返回的时候，就会将这个函数从栈顶弹出。
        4：每一个进入调用栈的都称为调用帧，方便堆栈追踪。
        5：堆栈溢出：调用堆栈中的函数调用数量超过了调用堆栈的实际大小，浏览器会抛出一个堆栈溢出错误
        6：并发与事件循环产生原因：当调用堆栈有函数要执行时，浏览器实际上不能做任何其他事情——它被阻塞了，如果函数执行所需时间过程就会造成卡顿，甚至报一个错误，询问你是否想终止 web 页面。
    cap2：
        1：v8引擎 性能高的原理（隐藏类，内联缓存）参考文章：https://zhuanlan.zhihu.com/p/27628685
           一般编译性语言在编译时，通过变量的数据类型来确认偏移量，运行时通过偏移量来计算出变量的内存地址，进而读取变量。而JavaScript是解释性语言，可以在运行时动态增删属性，所以一般用
           类似hashMap的key-value方式存储，这样就导致读取变量时效率较低。v8内部实现了一个隐藏类，当对new出的对象设置属性时，会动态的计算出该属性相对于隐藏类的偏移量，动态改变隐藏类。

           内联缓存，缓存之前的隐藏类，从而缓存之前的属性偏移量，来提升性能。

2021-02-04
    cap3：
        1：内存管理，编译器和操作系统管理内存，对于c，c++这种低级语言，需要开发者之间创建，释放内存。高级语言都有垃圾回收器，能帮助回收内存。
        2：垃圾回收算法：引用计数垃圾收集算法（无法解决循环引用的问题），标记-清除(Mark-and-sweep)算法
        3：内存泄露：
               全部变量--对存储大量数据的全局变量，用完一定要设置为null
               定时器和监听函数--用完要移除定时器和监听函数
               闭包--
               DOM引用--
    cap4：事件循环和异步编程
    cap5：websocket和HTTP/2
    cap6：WebAssembly
    cap7：Web Workers

2021-02-19：
    cap7：Web Workers：HTML5新特性，浏览器的功能，单独起一个线程，不阻塞页面渲染和事件循环（主线程），适用于大量计算的任务。具体应用如下：
          1：光线追踪
          2：加解密
    cap8：Service Workers
    cap11：渲染引擎和优化其性能的技巧
          1：浏览器包含：
                1：用户界面（user interface）,地址栏，前进，后退按钮，目录等
                2：浏览器引擎
                3：渲染引擎，解析渲染html，css
                4：js引擎（javascript engine）, 解析执行js
                5：网络（network）
                6：数据存储（cookie，localstorge），存储在本地硬盘
          2：渲染引擎，负责渲染html，xml，图片等，不同的插件可以渲染不同的文档类型，如pdf，flash
          3：跟js引擎一样，不同浏览器采用不同的渲染引擎：
                Firefox、Chrome 和 Safari 是基于两种渲染引擎构建的，Firefox 使用 Geoko——Mozilla 自主研发的渲染引擎，Safari 和 Chrome 都使用 Webkit。Blink 是 Chrome 基于 WebKit的自主渲染引擎
          4：渲染的过程：
                1：构建DOM树，渲染现引擎的第一步是解析 HTML文档，并将解析后的元素转换为 DOM 树中的实际 DOM 节点
                2：构建CSSOM
                3：构建渲染树，CSSOM 树和 DOM 树连接在一起形成一个 render tree，渲染树用来计算可见元素的布局并且作为将像素渲染到屏幕上的过程的输入
                    1：DOM 树和 CSSOM 树连接在一起形成 render tree
                    2：render tree 只包含了用于渲染页面的节点
                    3：布局计算了每一个对象的准确的位置以及大小
                    4：绘画是最后一步，绘画要求利用 render tree 来将像素显示到屏幕上
                4：渲染树的布局。HTML使用流的布局模型，从根节点开始递归，开始布局过程意味着给每个节点在屏幕上应该出现的确切坐标。
                5：绘制渲染树，的来说，重要的中要理解绘图是一个渐进的过程。为了更好的用户体验，渲染引擎将尽可能快地在屏幕上显示内容。它不会等到解析完所有 HTML 后才开始构建和布局渲染树，而是解析和显示部分内容，同时继续处理来自网络的其余内容项。
          5：为了构建渲染树，浏览器大致执行以下操作
                1：从 DOM 树根节点开始，遍历每一个可见的节点
                2：一些节点是完全不可见的（比如 script标签，meta标签等），这些节点会被忽略，因为他们不会影响渲染的输出
                3：一些节点是通过 CSS 样式隐藏了，这些节点同样被忽略——例如上例中的 span 节点在 render tree 中被忽略，因为 span 样式是 display:none
                4：对每一个可见的节点，找到合适的匹配的CSSOM规则，并且应用样式
                5：显示可见节点（节点包括内容和被计算的样式）


2021-02-20：
    cap12：深入网络层