重点章节：4,11,12,14,15,19,20,22

2021-02-03
    cap1：
        1：v8的两个主要组成部分：内存堆（数据存储的地方） 调用栈（代码执行的地方）。
        2：有一些浏览器的api不是由js引擎提供的，如dom,定时器（setTimeout），ajax等，我们称之为web api。
        3：js是一种单线程编程语言，只有一个调用堆栈。调用栈是一种数据结构，记录了我们在程序中的位置。运行一个函数时，它会将其放到栈顶，当从这个函数返回的时候，就会将这个函数从栈顶弹出。
        4：每一个进入调用栈的都称为调用帧，方便堆栈追踪。
        5：堆栈溢出：调用堆栈中的函数调用数量超过了调用堆栈的实际大小，浏览器会抛出一个堆栈溢出错误
        6：并发与事件循环产生原因：当调用堆栈有函数要执行时，浏览器实际上不能做任何其他事情——它被阻塞了，如果函数执行所需时间过程就会造成卡顿，甚至报一个错误，询问你是否想终止 web 页面。
    cap2：
        1：v8引擎 性能高的原理（隐藏类，内联缓存）参考文章：https://zhuanlan.zhihu.com/p/27628685
           一般编译性语言在编译时，通过变量的数据类型来确认偏移量，运行时通过偏移量来计算出变量的内存地址，进而读取变量。而JavaScript是解释性语言，可以在运行时动态增删属性，所以一般用
           类似hashMap的key-value方式存储，这样就导致读取变量时效率较低。v8内部实现了一个隐藏类，当对new出的对象设置属性时，会动态的计算出该属性相对于隐藏类的偏移量，动态改变隐藏类。

           内联缓存，缓存之前的隐藏类，从而缓存之前的属性偏移量，来提升性能。

2021-02-04
    cap3：
        1：内存管理，编译器和操作系统管理内存，对于c，c++这种低级语言，需要开发者之间创建，释放内存。高级语言都有垃圾回收器，能帮助回收内存。
        2：垃圾回收算法：引用计数垃圾收集算法（无法解决循环引用的问题），标记-清除(Mark-and-sweep)算法
        3：内存泄露：
               全部变量--对存储大量数据的全局变量，用完一定要设置为null
               定时器和监听函数--用完要移除定时器和监听函数
               闭包--
               DOM引用--
    cap4：事件循环和异步编程
    cap5：websocket和HTTP/2
    cap6：WebAssembly
    cap7：Web Workers

2021-02-19：
    cap7：Web Workers：HTML5新特性，浏览器的功能，单独起一个线程，不阻塞页面渲染和事件循环（主线程），适用于大量计算的任务。具体应用如下：
          1：光线追踪
          2：加解密
    cap8：Service Workers
    cap11：渲染引擎和优化其性能的技巧
          1：浏览器包含：
                1：用户界面（user interface）,地址栏，前进，后退按钮，目录等
                2：浏览器引擎
                3：渲染引擎，解析渲染html，css
                4：js引擎（javascript engine）, 解析执行js
                5：网络（network）
                6：数据存储（cookie，localstorge），存储在本地硬盘
          2：渲染引擎，负责渲染html，xml，图片等，不同的插件可以渲染不同的文档类型，如pdf，flash
          3：跟js引擎一样，不同浏览器采用不同的渲染引擎：
                Firefox、Chrome 和 Safari 是基于两种渲染引擎构建的，Firefox 使用 Geoko——Mozilla 自主研发的渲染引擎，Safari 和 Chrome 都使用 Webkit。Blink 是 Chrome 基于 WebKit的自主渲染引擎
          4：渲染的过程：
                1：构建DOM树，渲染现引擎的第一步是解析 HTML文档，并将解析后的元素转换为 DOM 树中的实际 DOM 节点
                2：构建CSSOM
                3：构建渲染树，CSSOM 树和 DOM 树连接在一起形成一个 render tree，渲染树用来计算可见元素的布局并且作为将像素渲染到屏幕上的过程的输入
                    1：DOM 树和 CSSOM 树连接在一起形成 render tree
                    2：render tree 只包含了用于渲染页面的节点
                    3：布局计算了每一个对象的准确的位置以及大小
                    4：绘画是最后一步，绘画要求利用 render tree 来将像素显示到屏幕上
                4：渲染树的布局。HTML使用流的布局模型，从根节点开始递归，开始布局过程意味着给每个节点在屏幕上应该出现的确切坐标。
                5：绘制渲染树，的来说，重要的中要理解绘图是一个渐进的过程。为了更好的用户体验，渲染引擎将尽可能快地在屏幕上显示内容。它不会等到解析完所有 HTML 后才开始构建和布局渲染树，而是解析和显示部分内容，同时继续处理来自网络的其余内容项。
          5：为了构建渲染树，浏览器大致执行以下操作
                1：从 DOM 树根节点开始，遍历每一个可见的节点
                2：一些节点是完全不可见的（比如 script标签，meta标签等），这些节点会被忽略，因为他们不会影响渲染的输出
                3：一些节点是通过 CSS 样式隐藏了，这些节点同样被忽略——例如上例中的 span 节点在 render tree 中被忽略，因为 span 样式是 display:none
                4：对每一个可见的节点，找到合适的匹配的CSSOM规则，并且应用样式
                5：显示可见节点（节点包括内容和被计算的样式）


2021-02-20：
    cap12：深入网络层
    cap13：SS 和 JS 动画底层原理及如何优化它们的性能
    cap14：JavaScript 是如何工作的：解析、抽象语法树（AST）+ 提升编译速度5个技巧
           1：无论是解释性语言（JavaScript，python），还是编译性语言（java，c#），都有一个共同点：将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。
           2：如果希望实现一个将 Python 代码转换为JavaScript 的转换器。基本思想是使用Python 转换器生成 AST，然后使用 AST 生成JavaScript代码。
           3：通常情况下，浏览器解析 JavaScript 大约需占总执行时间的 15% 到 20%，即将js构建出AST，移动浏览器的情况会更加复杂，解析时间是pc浏览器的2到5倍。
           4：V8 实现脚本流(script streaming)和代码缓存技术。
                1：脚本流即脚本一旦开始下载，async 和 deferred的 脚本就会在单独的线程上解析。这意味着在下载脚本完成后几乎立即完成解析，这会提升 10% 的页面加载速度。
                2：每次访问页面时，JavaScript 代码通常编译为字节码。 然而，一旦用户访问另一页面，该字节码就被丢弃。 发生这种情况是因为编译后的代码很大程度上依赖于编译时机器的状态和上下文。 这是 Chrome 42 引入字节码缓存的原因。 该技术会本地缓存编译过的代码，这样当用户返回同一页面时，诸如下载，解析和编译等所有步骤都会被跳过。 这使得 Chrome 可以节省大约 40％ 的解析和编译时间。 此外，这还可以节省移动设备的电量
           5：预编译
                1：从本质上讲，该思路是拥有可以生成字节码的务器端工具，这样只需要传输字节码并在客户端运行，之后会看到启动时间的一些主要差异。 这可能听起来很诱人，但事情并非那么简单，还可能会产生相反的效果，因为它会更大，并且很可能需要签署代码并出于安全原因对其进行处理。 例如，V8 团队正在努力解决重复解析问题，这样预编译有可能实际并没有多大的用处。
           6：提升编译速度
                1：检查依赖，减少不必要的依赖
                2：分割代码为更小的块而不是一整陀的
                3：尽可能推迟加载 JavaScript，按需要加载或者动态加载
                4：使用开发者工具和 DeviceTiming 来检测性能瓶颈
                5：使用像 Optimize.js 的工具来帮助解析器选择立即解析或者懒解析以加快解析速度
    cap15：深入类和继承内部原理+Babel和 TypeScript 之间转换
                1：ES6转ES5过程：
                    1：编写ES6代码
                    2：babylon 进行解析
                    3：解析得到 AST
                    4：plugin 用 babel-traverse 对 AST 树进行遍历转译
                    5：得到新的 AST树
                    6：用 babel-generator 通过 AST 树生成 ES5 代码
    cap17：Shadow DOM 的内部结构+如何编写独立的组件


2021-02-22
    cap22：JavaScript 的共享传递和按值传递
            1：共享传递：对于传递到函数参数的对象类型，如果直接改变了拷贝的引用的指向地址，那是不会影响到原来的那个对象；如果是通过拷贝的引用，去进行内部的值的操作，那么就会改变到原来的对象的。